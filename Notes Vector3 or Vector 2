This notes is based on How to Program: Camera-Relative Movement for PlayerObj.
  In doing so, we must understand Vector3. 

/////////////////////////////////////////////////Defination///////////////////////////////////////////////////////////////////////////
In Math, we can use Vectors to describe Movement. Vector is a measured of direction and distance in world.space.  
  Vectors are typically visualed as a line with an arrow at one end.  The Length of the line the vector's magnitude and the arrow represents the vector's direction. 
    The Vector consists of 2 points.  The head and the tail.  
      The head represent the placement of the arrow and signifying which direction the vetor is pointed. 
  Programing in unity, movement in 3D space defined and performed using a Vector3.  A Vector3 has direction and magitude which are calculated from the head and the tail.  
    However, there are 3 points in 3D space, X,Y,Z // well duh.   
      Vector 2 has 2 points in 2D space X,Y
      When instantiatign a new Vector3, the tail of a Vector3 will always be 0 on the X, Y,Z axis.  WHile the head can be at location in 3D space. 
example
Vector3 (0,0,0)
Vector3 exampleVector = New Vector3(2,0,0);

//////////// Normalized ////////////
We will be hearing normalized when we are dealing vector.  

Defination - Normalized : referes to process of scacling vector to have a length (magitude) of 1.  Normalized is needed to make the math of the vector and calculation more predictible and consistent. 
It will still point towards the same direction but has a length of 1. We will be using normalized for Vector3 or Vector2. 

Example

Vector3 originVector = new Vector (2.0f, 3.0f, -0.5);
Vector3 normalizedVector = originsVector.normalized;

Normalization is often used in variou development.  It would be use for movement and direction vectors, physics calculations, or lighting calculations.  

////////////////////////////////// Camera Relative Momvent code as an example for discusing VECTOR3 ///////////////////////////////////////////////////////////////////////////////////////////
// we will be using this as reference for down below notes. //

// Get the player Input (original input system)
float playerVerticalInput = Input.GetAxis("Vertical");
float playerHorizontalInput = Input.GetAxis("Horizontal");

// Get Camera-Normalized Dicrection Vectors
Vector3 forward = Camera.Main.transform.forward;
Vector3 right = Camera.Main.transform.right;

//Create Direction Relative Input Vectors
Vectors3 forwardRelativeVerticalInput = playerVerticalInput * Forward;
Vectors3 rightRelativeVerticalInput = playerHorizontalInput * right;

// Create CameraRelativeMovement
Vector3 cameraRelativeMovement = forardRelativeVerticalInput + rightRelativeVerticalInput;

transform.Translate(cameraRelativeMovement, Space.World);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

A vector3's direction can be calculated from the angles generated from all 3 axis to the Vector.  Now, "Direction" is a key term to understand here.
  All movement has direction, and in Unity, positive momvent on the Z axis.
  Positive movment in the Z-axis is considered "Foward" movement.  
  Positive movement in the Y-axis is considered "Up" movement.
  Positive momvent in the X-axis is considered "Right" movement.
Each of these can be represented by "Unit Vector".
A unit vector is a normalized Vector, and that means it's magnitude, or total length is 1.  //Normalizing is converting the new value to a true/magitude value (which is 1).  // I hope that make sense.
    // how come we don't type normalized in our reference code?   Perhaps we don't need to/want to because we want the new value and do the math with it to get the corret value?  
  Forward Z, Up Y, and Right X, the unit vector for the forward direction is 0,0,1. 
 Unit Vector: Up direction = 0,1,0.  Right = 1,0,0. 

Now if we want to continue to have a Camera-Relative Movement.  We want the data from the camera position.  
Vector3 forward = Camera.main.transform.forward;
Vector3 right = Camera.main.transform.right;
  These are both Normalized vectors. Meaning they are both what we now understand to be unit vectors: they have the length of 1(magitude). 

There are many possible ways it can be programmed in Unity.  We can use multiple different methods. We could use...

//////////////////// Options Code //////////////////
void HandleMovment() {
  transform.Tranlate(new vector3(0,0,1) * Time.deltaTime); // transform.Translate method
  transofrm.postion += new Vector3(0,0,1) * Time.deltaTime; // we can also update transorms's position directly
  _characterController.Move(new Vector3(0,0,1) * Time.deltaTime); //unity BBIC
  rb.AddForce(new Vector3(0.0,1) * Time.deltaTime); // we can move using physics with AddForce
  rb.AddRelativeForce(new Vector3(0,0,1) * Time.deltaTime); // we can move using AddRelativeForce
  rb.MovePosition(new Vector3(0,0,1) *Time.deltaTime); // MovePosition methods
  rb.velocity = new Vector3(0.0.1); directly setting the velocity of a RB component. 
All of these options either apply a Vector 3 to the gameOBj or they are a Vector3 attribute of the gameObj which we are then overriding.
  any of the methods could be good practice or there are other alternative, the point of all this to this is to understand "Coordinate Space"

//////////////////////////////////////////////////////////////////////////////////////

-Coordinate Space- 
  There are two "Spaces" in which the gameOjb operates and can move through Unity's coordinate system using Vector3s..  There are World.Space and Local.Space.
World Space
  is a Static Coordinate System. The Vector3 doesn't change and if we to apply a transformation to the position of a gameObj relative to t World Space=, the gameObj would always move along these constant X,Y,Z axes. 
Local Space
  Applying transform values relative to Local Space applies movement to the local coordinate system. Whle the static and unchanging World.Space stands as the source of truth in Unity because it doesn't change, 
    local space is variable and is based rotation of the gameObj relative to the world's default rotation. It's this rotation that determines the forward, up, and right direction, and the axes in local space. 
Both are vairable are usuable.  
World.Space can be converted to Local.Space and Local.Space can be converted to World.Space or another Local.Space. if you convert Local space to World.Space, the coords will be different.  
    It could be something like (6,-6,-4) It will depends on gameObj's rotation. 

////////// World Space //////////////
  Transform.Translate(movment, Space.World);
  _rb MovePosition(movment);
  _characterController.Move(movement);
  _rb. AddForce(movement);

///////// Local Space //////////////
  _rb.AddRelativeForce(movement);
  transform.Translate(movement);

//////////////////////////////////////

Stepping back into prevous code on the Vector3 foward = Camera.main.transform.right; This cmera-based momvent code privode the normalized direction vectors on our camera. Which are the directions we want out charcter to move.
  We undestands Camera.Main.Transform.right is the camera's right Vector 3 that hs values relative to world space, which is why it isn't guranteed to be 0,0,1.
    But relative to local space, it would be.  The world right vector relative to local.space might be something different. 
IF we have 2 coordinate space and a Vector is set in one coordinate space, we can transform from one coordiante space to another one.

What this means is that the angles gernearte from each axis to that vector in it's original coordiate space, would have a comparable angle for the new vector and axes in the coordinate space it was transformed to.  
  but how does this rotation work?  Answer: Math!  If we have the normalized forward and right vectors of a new coordiate space who values are relative to or have been converted to, 
    the coordiate space that the vector we are trying to rotate is currently in: we can then multiply each directional unit vector by it's correspodning axis value. Forward Z, Right X. 

By then adding the products together, we create a new vector. 
    and this resulting vector will have the same angle to the new coordinate space. The values will still be in the original coordinate space, but if converted to the new coordinate space, 
      they are the original values. //weeeeee! 
Going back to finding the Camera Relative Movement, we want to take the Vector3 forwardVerticalInput = playerVertical Input * Forward(also the right value). That will give us the new value. Then add these products together: 
    we successfully rotate the original player input movment vector!
    This results now retains the same angle relative to the camera's coordinate space. 


    //if we want more in depth, let's find Freya specifically "rotating vectors"
By this time, we have gotten our full value of our New Vector3 for our cameraRelativeMovement.  Now, for this situation, we need to specify Space.World because our values from World.Space. 

/////////// Local.Space Example ////////////
Now if we want to utilized Local Space, we have to altered certain lines of codes. 
// Get Camera=Normalized Directional Vectors
Vector3 forward = transform.InverseTransformVector(Camera.main.transform.forward);
Vector3 right = transform.InverseTransformVector(Camera.main.transform.right);
  Keep in mind Transform.InverseTransformVector : Transform a vector from World.Space to Local.Space. The oppsoite of Transform.TransfromVector.  
    This operation is affected by the scale of the gameObj. If the gameObj is a scale of 2, then the Inverse TransfromVector migh be half the size. 
      This would caused a bit of issues.  To prevent any issues, you can normalized the reust to ensure that it's a proper unit vector.  

//////// What if the camera goes up or down ////////////////////

Based on our current code, if you tilt the camera, our game obj will go vector3.up.  So, what we need to do to prevent this, we need to give the value of Y.  Then normalized it.  

// 0 out the y so when you tilt the camera in the Y-Axis, then the character doesn't move up or down.  This will remove the Y value of both stored vectors and normalized them to ignore upward and downard camera angles
  The characterObj will stay on the ground. 
forward.y = 0; 
right.y = 0;
   Then we normalized the Vectors
forward = forward.normalized;
right = right.normalized;


////////////// Final Code for Camera Relative Character Movement for Vector3 //////////////////////////////

private void MovePlayerRelativeToCamera()
{
    //player input
    float playerVerticalInput = Input.GetAxis("Vertical");
    float playerHorizontalInput = Input.GetAxis("Horizontal");

    
    // get Camera Normalized Directional Vectors
    Vector3 forward = Camera.main.transform.forward;
    Vector3 right = Camera.main.transform.right;
    // 0 out the y so when you tilt the camera in the Y-Axis, then the character doesn't move up or down.  They will stay on the ground. 
    forward.y = 0; 
    right.y = 0;
    // after adding the value with y axis, we are normalizing the value with Vector 3.  
    forward = forward.normalized;
    right = right.normalized;

    // Create direction-relative-inputs vectors
    Vector3 forwardRelativeVerticalInput = playerVerticalInput * forward;
    Vector3 rightRelativeHorizontalInput = playerHorizontalInput * right;

    // Create and apply camera relative movement
    Vector3 cameraRelativeMovement = forwardRelativeVerticalInput + rightRelativeHorizontalInput;
    this.transform.Translate(cameraRelativeMovement * speed * Time.deltaTime, Space.World);
    
    if (cameraRelativeMovement != Vector3.zero)
    {
        transform.forward = cameraRelativeMovement;
    }

   
}
